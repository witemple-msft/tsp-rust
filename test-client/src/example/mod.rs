// Generated by Microsoft TypeSpec

pub mod models {
    pub mod all {
        /// Some namespace documentation.
        pub mod example {
            #[derive(
                Debug,
                Clone,
                PartialEq,
                ::tsp_rust::vendored::serde::Deserialize,
                ::tsp_rust::vendored::serde::Serialize,
            )]
            #[serde(crate = "::tsp_rust::vendored::serde")]
            pub struct Error {
                pub body: super::super::synthetic::ErrorBody,
            }

            impl Error {
                #[allow(dead_code)]
                pub const CODE: i32 = 400;
            }

            /// A Foo example model.
            #[derive(
                Debug,
                Clone,
                PartialEq,
                ::tsp_rust::vendored::serde::Deserialize,
                ::tsp_rust::vendored::serde::Serialize,
            )]
            #[serde(crate = "::tsp_rust::vendored::serde")]
            pub struct Foo {
                /// A string field.
                pub a: String,

                /// A number field.
                pub b: u32,
            }

            impl Foo {
                #[allow(dead_code)]
                pub const SETTING: &'static str = "this is a setting";
            }

            /// An Output example model.
            #[derive(
                Debug,
                Clone,
                PartialEq,
                ::tsp_rust::vendored::serde::Deserialize,
                ::tsp_rust::vendored::serde::Serialize,
            )]
            #[serde(crate = "::tsp_rust::vendored::serde")]
            pub struct Output {
                /// A boolean field.
                pub x: bool,

                /// An anonymous model field.
                pub y: super::super::synthetic::OutputY,
            }

            /// Some example operations.
            pub trait Operations {
                /// The error type which may be returned by this trait's operations.
                type Error<OperationError>: std::error::Error + Send + Sync + 'static;

                /// A POST operation that uses application/json.
                fn json(
                    &mut self,
                    payload: Foo,
                ) -> impl ::tsp_rust::OperationFuture<Output, Self::Error<::core::convert::Infallible>>;
            }
        }

        /// A trait representing the operations defined in the 'Example' namespace.
        pub trait Example {
            /// The error type which may be returned by this trait's operations.
            type Error<OperationError>: std::error::Error + Send + Sync + 'static;

            /// A freestanding operation.
            fn freestanding(
                &mut self,
                foo: impl AsRef<str> + Send,
            ) -> impl ::tsp_rust::OperationFuture<
                super::synthetic::FreestandingResponse,
                Self::Error<example::Error>,
            >;

            /// A freestanding operation with a path parameter and query parameter.
            fn freestanding_path(
                &mut self,
                id: impl AsRef<str> + Send,
                q: impl AsRef<str> + Send,
            ) -> impl ::tsp_rust::OperationFuture<
                super::synthetic::FreestandingPathResponse,
                Self::Error<example::Error>,
            >;
        }
    }

    pub mod synthetic {
        #[derive(
            Debug,
            Clone,
            PartialEq,
            ::tsp_rust::vendored::serde::Deserialize,
            ::tsp_rust::vendored::serde::Serialize,
        )]
        #[serde(crate = "::tsp_rust::vendored::serde")]

        pub struct FreestandingResponse {
            pub bar: String,

            pub example: Vec<u8>,
        }

        impl FreestandingResponse {
            #[allow(dead_code)]

            pub const CODE: i32 = 200;
        }

        #[derive(
            Debug,
            Clone,
            PartialEq,
            ::tsp_rust::vendored::serde::Deserialize,
            ::tsp_rust::vendored::serde::Serialize,
        )]
        #[serde(crate = "::tsp_rust::vendored::serde")]

        pub struct ErrorBody {
            pub message: String,
        }

        #[derive(
            Debug,
            Clone,
            PartialEq,
            ::tsp_rust::vendored::serde::Deserialize,
            ::tsp_rust::vendored::serde::Serialize,
        )]
        #[serde(crate = "::tsp_rust::vendored::serde")]

        pub struct FreestandingPathResponse {
            pub composite: String,

            pub example: Vec<u8>,
        }

        impl FreestandingPathResponse {
            #[allow(dead_code)]

            pub const CODE: i32 = 200;
        }

        #[derive(
            Debug,
            Clone,
            PartialEq,
            ::tsp_rust::vendored::serde::Deserialize,
            ::tsp_rust::vendored::serde::Serialize,
        )]
        #[serde(crate = "::tsp_rust::vendored::serde")]

        pub struct OutputY {
            /// A decimal field.
            pub z: ::tsp_rust::vendored::bigdecimal::BigDecimal,
        }
    }
}

pub mod http {
    pub mod operations {
        pub mod client_raw {
            #[allow(unused)]
            pub async fn freestanding<
                ResponseBody: ::tsp_rust::vendored::http_body::Body,
                S: ::tsp_rust::http::Service<ResponseBody>,
            >(
                service: &mut S,
                foo: impl AsRef<str> + Send,
            ) -> Result<
                super::super::super::models::synthetic::FreestandingResponse,
                ::tsp_rust::http::Error<
                    ResponseBody,
                    S::Error,
                    super::super::super::models::all::example::Error,
                >,
            > {
                use ::tsp_rust::http::Error as HttpError;

                let request = ::tsp_rust::vendored::http::Request::builder()
                    .method(::tsp_rust::vendored::http::Method::GET)
                    .header("X-Foo", foo.as_ref())
                    .uri("/freestanding")
                    .body(::tsp_rust::http::Body::new(Box::pin(
                        ::tsp_rust::vendored::futures::stream::empty(),
                    )))
                    .unwrap();

                let response = ::tsp_rust::http::send_request(service, request).await?;
                #[allow(unused_variables)]
                let (parts, body) = response.into_parts();

                let status_code = parts.status.as_u16();

                let content_type = parts
                    .headers
                    .get("content-type")
                    .map(|h| {
                        String::from(
                            h.to_str()
                                .expect("failed to convert header contents to String"),
                        )
                    })
                    .ok_or_else(|| {
                        ::tsp_rust::http::Error::UnexpectedContentType(None, parts.clone())
                    })?;

                match status_code {
                    200 => match content_type.as_str() {
                        "application/json" => {
                            let body: Vec<u8> = ::tsp_rust::http::deserialize_body(body).await?;

                            Ok(::tsp_rust::http::FromResponse::from_response(body, parts))
                        }
                        _ => Err(HttpError::UnexpectedContentType(Some(content_type), parts)),
                    },
                    400 => match content_type.as_str() {
                        "application/json" => {
                            let body: super::super::super::models::synthetic::ErrorBody =
                                ::tsp_rust::http::deserialize_body(body).await?;

                            Err(HttpError::Operation(
                                ::tsp_rust::http::FromResponse::from_response(body, parts),
                            ))
                        }
                        _ => Err(HttpError::UnexpectedContentType(Some(content_type), parts)),
                    },
                    code => Err(HttpError::UnexpectedStatus(code, parts)),
                }
            }

            #[allow(unused)]
            pub async fn freestanding_path<
                ResponseBody: ::tsp_rust::vendored::http_body::Body,
                S: ::tsp_rust::http::Service<ResponseBody>,
            >(
                service: &mut S,
                id: impl AsRef<str> + Send,
                q: impl AsRef<str> + Send,
            ) -> Result<
                super::super::super::models::synthetic::FreestandingPathResponse,
                ::tsp_rust::http::Error<
                    ResponseBody,
                    S::Error,
                    super::super::super::models::all::example::Error,
                >,
            > {
                use ::tsp_rust::http::Error as HttpError;

                let request = ::tsp_rust::vendored::http::Request::builder()
                    .method(::tsp_rust::vendored::http::Method::POST)
                    .uri(format!(
                        "/freestanding/{}?q={}",
                        ToString::to_string(id.as_ref()),
                        q.as_ref()
                    ))
                    .body(::tsp_rust::http::Body::new(Box::pin(
                        ::tsp_rust::vendored::futures::stream::empty(),
                    )))
                    .unwrap();

                let response = ::tsp_rust::http::send_request(service, request).await?;
                #[allow(unused_variables)]
                let (parts, body) = response.into_parts();

                let status_code = parts.status.as_u16();

                let content_type = parts
                    .headers
                    .get("content-type")
                    .map(|h| {
                        String::from(
                            h.to_str()
                                .expect("failed to convert header contents to String"),
                        )
                    })
                    .ok_or_else(|| {
                        ::tsp_rust::http::Error::UnexpectedContentType(None, parts.clone())
                    })?;

                match status_code {
                    200 => match content_type.as_str() {
                        "application/json" => {
                            let body: Vec<u8> = ::tsp_rust::http::deserialize_body(body).await?;

                            Ok(::tsp_rust::http::FromResponse::from_response(body, parts))
                        }
                        _ => Err(HttpError::UnexpectedContentType(Some(content_type), parts)),
                    },
                    400 => match content_type.as_str() {
                        "application/json" => {
                            let body: super::super::super::models::synthetic::ErrorBody =
                                ::tsp_rust::http::deserialize_body(body).await?;

                            Err(HttpError::Operation(
                                ::tsp_rust::http::FromResponse::from_response(body, parts),
                            ))
                        }
                        _ => Err(HttpError::UnexpectedContentType(Some(content_type), parts)),
                    },
                    code => Err(HttpError::UnexpectedStatus(code, parts)),
                }
            }

            #[allow(unused)]
            pub async fn json<
                ResponseBody: ::tsp_rust::vendored::http_body::Body,
                S: ::tsp_rust::http::Service<ResponseBody>,
            >(
                service: &mut S,
                payload: super::super::super::models::all::example::Foo,
            ) -> Result<
                super::super::super::models::all::example::Output,
                ::tsp_rust::http::Error<ResponseBody, S::Error, ::core::convert::Infallible>,
            > {
                use ::tsp_rust::http::Error as HttpError;

                let request = ::tsp_rust::vendored::http::Request::builder()
                    .method(::tsp_rust::vendored::http::Method::POST)
                    .uri("/operations/json")
                    .header("content-type", "application/json")
                    .body(::tsp_rust::http::Body::new(Box::pin(
                        ::tsp_rust::vendored::futures::stream::once(
                            ::tsp_rust::vendored::futures::future::ready(Ok(
                                ::tsp_rust::vendored::http_body::Frame::data(
                                    ::tsp_rust::vendored::serde_json::to_vec(&payload)
                                        .map_err(HttpError::Serialize)?
                                        .into(),
                                ),
                            )),
                        ),
                    )))
                    .unwrap();

                let response = ::tsp_rust::http::send_request(service, request).await?;
                #[allow(unused_variables)]
                let (parts, body) = response.into_parts();

                let status_code = parts.status.as_u16();

                let content_type = parts
                    .headers
                    .get("content-type")
                    .map(|h| {
                        String::from(
                            h.to_str()
                                .expect("failed to convert header contents to String"),
                        )
                    })
                    .ok_or_else(|| {
                        ::tsp_rust::http::Error::UnexpectedContentType(None, parts.clone())
                    })?;

                match status_code {
                    200 => match content_type.as_str() {
                        "application/json" => {
                            let body: super::super::super::models::all::example::Output =
                                ::tsp_rust::http::deserialize_body(body).await?;

                            Ok(body)
                        }
                        _ => Err(HttpError::UnexpectedContentType(Some(content_type), parts)),
                    },
                    code => Err(HttpError::UnexpectedStatus(code, parts)),
                }
            }
        }

        pub mod server_raw {
            pub async fn freestanding<
                E: super::super::super::models::all::Example,
                RequestBody: ::tsp_rust::vendored::http_body::Body + Send + Sync,
            >(
                mut service: E,
                request: ::tsp_rust::vendored::http::Request<RequestBody>,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<
                    RequestBody,
                    E::Error<super::super::super::models::all::example::Error>,
                >,
            > {
                #[allow(unused_variables)]
                let (parts, body) = request.into_parts();

                let foo = parts.headers.get("X-Foo").and_then(|h| h.to_str().ok());
                let Some(foo) = foo else {
                    return Err(::tsp_rust::http::ServerError::InvalidRequest);
                };

                let result = service
                    .freestanding(foo)
                    .await
                    .map_err(::tsp_rust::http::ServerError::Operation)?;

                ::tsp_rust::http::Responder::to_response(result)
            }

            pub async fn freestanding_path<
                E: super::super::super::models::all::Example,
                RequestBody: ::tsp_rust::vendored::http_body::Body + Send + Sync,
            >(
                mut service: E,
                request: ::tsp_rust::vendored::http::Request<RequestBody>,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<
                    RequestBody,
                    E::Error<super::super::super::models::all::example::Error>,
                >,
            > {
                #[allow(unused_variables)]
                let (parts, body) = request.into_parts();

                #[allow(unused_parens)]
                let (id) = ::tsp_rust::vendored::eyes::parse!(
                    parts.uri.path(),
                    "/freestanding/{}",
                    String
                );

                let mut q = None;

                let query_params = parts
                    .uri
                    .query()
                    .map(|query| {
                        ::tsp_rust::vendored::url::form_urlencoded::parse(query.as_bytes())
                    })
                    .ok_or(::tsp_rust::http::ServerError::InvalidRequest)?;

                for (k, v) in query_params {
                    #[allow(clippy::single_match)]
                    match k.as_ref() {
                        "q" => {
                            q = Some(v);
                        }
                        _ => {}
                    }
                }

                let Some(q) = q else {
                    return Err(::tsp_rust::http::ServerError::InvalidRequest);
                };

                let result = service
                    .freestanding_path(id, q)
                    .await
                    .map_err(::tsp_rust::http::ServerError::Operation)?;

                ::tsp_rust::http::Responder::to_response(result)
            }

            pub async fn json<
                E: super::super::super::models::all::example::Operations,
                RequestBody: ::tsp_rust::vendored::http_body::Body + Send + Sync,
            >(
                mut service: E,
                request: ::tsp_rust::vendored::http::Request<RequestBody>,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<RequestBody, E::Error<::core::convert::Infallible>>,
            > {
                #[allow(unused_variables)]
                let (parts, body) = request.into_parts();

                let payload = ::tsp_rust::http::deserialize_body_server(body).await?;

                let result = service
                    .json(payload)
                    .await
                    .map_err(::tsp_rust::http::ServerError::Operation)?;

                ::tsp_rust::http::Responder::to_response(result)
            }
        }
    }

    mod _impls {
        impl ::tsp_rust::http::FromResponse<Vec<u8>>
            for super::super::models::synthetic::FreestandingResponse
        {
            #[allow(unused)]
            fn from_response(
                body: Vec<u8>,
                parts: ::tsp_rust::vendored::http::response::Parts,
            ) -> Self {
                Self {
                    bar: parts
                        .headers
                        .get("X-Bar")
                        .map(|h| h.to_str().unwrap())
                        .unwrap()
                        .into(),
                    example: body,
                }
            }
        }

        impl ::tsp_rust::http::FromResponse<super::super::models::synthetic::ErrorBody>
            for super::super::models::all::example::Error
        {
            #[allow(unused)]
            fn from_response(
                body: super::super::models::synthetic::ErrorBody,
                parts: ::tsp_rust::vendored::http::response::Parts,
            ) -> Self {
                Self { body }
            }
        }

        impl ::tsp_rust::http::FromResponse<Vec<u8>>
            for super::super::models::synthetic::FreestandingPathResponse
        {
            #[allow(unused)]
            fn from_response(
                body: Vec<u8>,
                parts: ::tsp_rust::vendored::http::response::Parts,
            ) -> Self {
                Self {
                    composite: parts
                        .headers
                        .get("X-Composite")
                        .map(|h| h.to_str().unwrap())
                        .unwrap()
                        .into(),
                    example: body,
                }
            }
        }

        impl ::tsp_rust::http::Responder for super::super::models::synthetic::FreestandingResponse {
            fn to_response<B: ::tsp_rust::vendored::http_body::Body, E: std::error::Error>(
                self,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<B, E>,
            > {
                let response = ::tsp_rust::vendored::http::Response::builder()
                    .status(Self::CODE as u16)
                    .header("content-type", "application/json")
                    .header("X-Bar", self.bar)
                    .body(
                        ::tsp_rust::http::serialize_json_body(&self.example)
                            .map_err(::tsp_rust::http::ServerError::Serialize)?,
                    )
                    .unwrap();

                Ok(response)
            }
        }

        impl ::tsp_rust::http::Responder for super::super::models::all::example::Error {
            fn to_response<B: ::tsp_rust::vendored::http_body::Body, E: std::error::Error>(
                self,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<B, E>,
            > {
                let response = ::tsp_rust::vendored::http::Response::builder()
                    .status(Self::CODE as u16)
                    .header("content-type", "application/json")
                    .body(
                        ::tsp_rust::http::serialize_json_body(&self.body)
                            .map_err(::tsp_rust::http::ServerError::Serialize)?,
                    )
                    .unwrap();

                Ok(response)
            }
        }

        impl ::tsp_rust::http::Responder for super::super::models::synthetic::FreestandingPathResponse {
            fn to_response<B: ::tsp_rust::vendored::http_body::Body, E: std::error::Error>(
                self,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<B, E>,
            > {
                let response = ::tsp_rust::vendored::http::Response::builder()
                    .status(Self::CODE as u16)
                    .header("content-type", "application/json")
                    .header("X-Composite", self.composite)
                    .body(
                        ::tsp_rust::http::serialize_json_body(&self.example)
                            .map_err(::tsp_rust::http::ServerError::Serialize)?,
                    )
                    .unwrap();

                Ok(response)
            }
        }

        impl ::tsp_rust::http::Responder for super::super::models::all::example::Output {
            fn to_response<B: ::tsp_rust::vendored::http_body::Body, E: std::error::Error>(
                self,
            ) -> Result<
                ::tsp_rust::vendored::http::Response<::tsp_rust::http::Body>,
                ::tsp_rust::http::ServerError<B, E>,
            > {
                let response = ::tsp_rust::vendored::http::Response::builder()
                    .status(200u16)
                    .body(::tsp_rust::http::Body::new(Box::pin(
                        ::tsp_rust::vendored::futures::stream::empty(),
                    )))
                    .unwrap();

                Ok(response)
            }
        }
    }
}

#[allow(unused_imports)]
pub use models::all::example::*;
