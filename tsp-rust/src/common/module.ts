import { EmitContext, getService } from "@typespec/compiler";
import { HttpService, getAuthentication, getServers } from "@typespec/http";
import { generateAuth } from "../http/auth.js";
import { parseCase } from "../util/case.js";
import { RustContext } from "../ctx.js";
import { indent } from "../util/indent.js";
import { emitHttpOperations } from "../http/operation.js";
import {
  referenceHostPath,
  referenceVendoredHostPath,
} from "../util/vendored.js";
import { emitDeclarations } from "./declaration.js";
import { emitOptions } from "../http/options.js";
import { getServerDescription } from "../http/server.js";
import { createOnceQueue } from "../util/onceQueue.js";

// TODO: awful module, needs total rewrite

export function emitRust(ctx: EmitContext, service: HttpService): string {
  const code: string[] = [];

  code.push("// Generated by Microsoft TypeSpec");
  code.push("");

  const { title, version } = getService(ctx.program, service.namespace) ?? {};
  const authenticationInfo = getAuthentication(ctx.program, service.namespace);

  const serviceNameCase = parseCase(title ?? "Service");

  const contextTypeName = serviceNameCase.pascalCase + "Context";
  const errorTypeName = serviceNameCase.pascalCase + "Error";

  const serverInfo = getServers(ctx.program, service.namespace);

  if (serverInfo && serverInfo.length > 1) {
    throw new Error("Multiple servers are not supported yet");
  }

  const rustCtx: RustContext = {
    program: ctx.program,
    service: getService(ctx.program, service.namespace)!,
    httpService: service,
    authenticationInfo,
    serviceTitle: title,
    serviceVersion: version,

    contextTypeName,
    errorTypeName,

    typeQueue: createOnceQueue(),
    synthetics: [],
    syntheticNames: new Map(),

    options: [],

    rootModule: undefined as any,
    baseNamespace: service.namespace,
    namespaceModules: new Map(),
    syntheticUnions: new Set(),
    syntheticModule: undefined as any,
  };

  const auth = generateAuth(rustCtx);

  const serverDescription = getServerDescription(
    rustCtx,
    serverInfo?.[0],
    auth
  );

  const responseLines: string[] = [];

  const httpOperations = [...emitHttpOperations(rustCtx, auth, responseLines)];

  const response =
    responseLines.length > 0
      ? ["pub mod response {", ...indent(responseLines.slice(0, -1)), "}"]
      : [];

  const options = [...emitOptions(rustCtx)];

  for (const [_, iface] of service.namespace.interfaces) {
    rustCtx.typeQueue.add(iface);
  }

  code.push(
    "pub mod models {",
    ...indent(emitDeclarations(rustCtx)),
    "}",
    "",
    "pub mod http {",
    `  use ${referenceHostPath("QueryString")};`,
    `  use ${referenceHostPath("HeaderMap")};`,
    `  use ${referenceVendoredHostPath("itertools", "Itertools")};`,
    "",
    "  pub mod service_info {",
    `    pub const TITLE: &str = "${title ?? ""}";`,
    `    pub const VERSION: &str = "${version ?? ""}";`,
    "  }",
    "",
    ...indent(auth.declarations),
    "  #[non_exhaustive]",
    `  pub struct ${contextTypeName} {`,
    // prettier-ignore
    `    client: ${referenceVendoredHostPath("reqwest", "Client")},`,
    "    pub base_url: String,",
    ...indent(indent(auth.config_lines)),
    "  }",
    "  ",
    `  pub struct ${contextTypeName}Init {`,
    "    pub base_url: String,",
    ...indent(indent(auth.config_lines)),
    "  }",
    "  ",
    `  impl ${contextTypeName} {`,
    `    pub fn new(init: ${contextTypeName}Init) -> Self {`,
    `      Self {`,
    `        client: ${referenceVendoredHostPath("reqwest", "Client")}::new(),`,
    `        base_url: init.base_url,`,
    ...auth.fields.map((field) => `        ${field}: init.${field},`),
    `      }`,
    `    }`,
    "",
    "    pub fn base_url(&self) -> () {}",
    "  }",
    "  ",
    ...indent(options),
    ...indent(response),

    ...indent(httpOperations),
    "}"
  );

  return code.join("\n");
}
